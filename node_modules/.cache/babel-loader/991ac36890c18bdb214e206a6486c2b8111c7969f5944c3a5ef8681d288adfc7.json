{"ast":null,"code":"import { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nconst cborEncoders = [];\ncborEncoders[Type.uint.major] = encodeUint;\ncborEncoders[Type.negint.major] = encodeNegint;\ncborEncoders[Type.bytes.major] = encodeBytes;\ncborEncoders[Type.string.major] = encodeString;\ncborEncoders[Type.array.major] = encodeArray;\ncborEncoders[Type.map.major] = encodeMap;\ncborEncoders[Type.tag.major] = encodeTag;\ncborEncoders[Type.float.major] = encodeFloat;\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.array, obj.length), entries];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.map, length), entries];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let refStack = arguments.length > 2 ? arguments[2] : undefined;\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","cborEncoders","uint","major","negint","bytes","string","array","map","tag","float","buf","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","arguments","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","encoders","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","toBytes","encode","assign"],"sources":["/home/luis/Escritorio/NFT_marketplace/NFT-market/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nconst cborEncoders = [];\ncborEncoders[Type.uint.major] = encodeUint;\ncborEncoders[Type.negint.major] = encodeNegint;\ncborEncoders[Type.bytes.major] = encodeBytes;\ncborEncoders[Type.string.major] = encodeString;\ncborEncoders[Type.array.major] = encodeArray;\ncborEncoders[Type.map.major] = encodeMap;\ncborEncoders[Type.tag.major] = encodeTag;\ncborEncoders[Type.float.major] = encodeFloat;\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}